자료구조 4주차 이론-1

p.12
Queues
우리가 익숙한 일반적인 줄


p.13
Fist in Fist out 구조 (FIFO, 선입선출)
또는 Last in Last out (LILO, 후입후출)

공정하기 때문에 줄서서 서비스를 할때 queue를 사용

데이터가 들어오는 곳은 rear, 나가는곳은 front.

당연하지만 이러한 내부적인 내용은 외부에서 알 수 없다.
데이터를 관리하는 우리는 알아야하는 것.

enqueue : 큐의 맨뒤에 데이터를 입력하는 것. 개념적으로 줄 세우는것.
개념적으로 줄세운다는 뜻은 은행에서 번호표를 받고 기다릴때 아무데나 앉아서 기다려도 상관없다. 번호표로 개념적으로 줄세우는거지. 물리적으로 줄세울 필요는 없다는 뜻

dequeue : 맨앞에있는 데이터 remove

큐에서는 마지막으로 들어온 사람(데이터)에 대해서는 일반적으로 관심이 없다. (왜냐하면 맨 마지막에 다룰거기때문에)

따라서 맨 앞에 있는 element를 return해주는 front()라는 함수 존재.


p.14
간단한 예시


p.15
큐의 이용


p.16
큐의 구현. by 배열.
배열을 circular fashion으로 구현한다. (환형배열)
예를들어 환형배열이 아니면,
배열의 크기가 5일때, 0부터 4번 index까지 element가 다찼다
0번과 1번이 dequeue되고, 새로운 데이터를 enqueue할 때
5번 index는 존재하지않으니까 새로운 데이터를 넣을 수 없다.
따라서 환형배열은 다시 0번부터 데이터를 넣는것. (개념적으로만. 물리적으로 굳이 원형이라는 뜻은 x)
그렇다면 5번째 들어온 데이터는 0번 인덱스지만 순서는 5번째인것.

따라서 array로 구현하려면 f, r 인덱스가 필요하다. 그리고 n까지.
f와 r은 나머지연산(modulo, %)연산을 통해 유지시킨다.


p.17
수도코드로 먼저 구현해보자.
탐색

P.18
삽입연산
O(1) time

P.19
삭제연산
O(1) time

p.20
싱글리 링크드 리스트로 구현













