10주차 자료구조 이론-1

지난수업복습.

Priority Queue란,
key와 value라는 한 쌍의 엔트리(또는 아이템)을 저장한다.

min PQ와 max PQ중 우리는 min PQ를 기준으로 한다.

sequence베이스로 구현할 때.
1. unsorted list -> selection sort
insert가 O(1)


2. sorted list -> insertion sort
insert가 O(n)


=> 100개미만, 20개전후일때 insertion sort가 더 빠르다.

inplace order

...

Heap
구조적인조건, 순서적인조건을 만족시키는 adt

last node는 완전이진트리를 생성할 때, 마지막에 생성된 노드이고, 이 노드를 tracing 하는 것이 중요.

p.13
min PQ를 구현하는 방법으로 Heap을 사용하겠다.

p.14
Heap을 이용해서 PQ를 구현하자.

insert(e)연산
removeMin()
min()
=> 탐색, 삽입, 삭제 연산을 구현해보자자.

먼저 insertion.
heap에 다가 어떤 데이터를 넣어도 heap이 되어야한다.
-> 즉 heap이 되기 위한 조건을 만족시켜야한다.

우선, 구조조건을 먼저 만족시켜주는게 쉽다.
왜냐하면, n개의 데이터를 저장하는 완전이진트리의 개수는 단 1개이기 때문이다.
이렇게되면 heap이 되기 위한 절반의 단계 만족.
-> 구조조건은 O(1)에 만족가능하다.

p.15
이제 순서조건을 만족시켜보자.

ppt 그림을 기준으로,
1. 새로추가된 노드인 1과 부모인 6을 비교, 1이더 작으므로 교체
2. 교체이후에도 반복적으로 부모와 비교후 교체.

Q. 교체를 진행할때, 부모랑만 크기를 비교해서 교체를 해도 되나? 교체 이후에도 반대쪽 서브트리가 반드시 heap 조건을 만족하나?
->부모랑만 비교해도된다. 형제노드는 볼필요가 없다.
왜냐하면 교체이전에도 반대쪽 서브트리는 heap이었었는데, 교체가 진행된다는 뜻은, 현재 부모노드보다 더 작은 노드로 바뀐다는 뜻이므로 무조건 만족하게 된다.

교체를 진행하는데, 최악의 경우 root까지 올라가므로 O(log(n))이다.

leaf에서부터 쭉 올라간다고 해서 Upheap이라고 부른다.


=>insert연산
구조 : O(1) -> last node를 안다는 가정하에서.
순서(upheap) : O(log(n))
-> 전체 O(log(n)) 시간.

p.16
heap에서의 삭제.
삭제역시 구조조건, 순서조건을 만족시켜야한다.
n개의 완전트리에서 1개를 삭제하여 n-1개의 완전트리가 되면, 역시나 구조모양은 1개.

min()연산은 O(1)시간이다. (루트노드니까)
removeMin을 한다는 뜻은 루트노드를 삭제 시키는것.
-> 두개의 서브트리로 쪼개진다. 그걸 다시 하나로 묶으려면 좀번거로우니, 일단은 간단하게 last node 위치를 알기때문에 last node를 삭제해서 루트로 옮긴다.

last node는 key값이 클 확률이 큰데, root로 올리게되면 순서조건을 다시 수정해야한다.

그렇다면, ppt그림에서, 7을 루트로 옮겼을때, left child랑 바꿔야하나,right child랑 바꿔야하나?
1. 해당노드의 left child와 right child 노드 크기를 비교.
2. 더 작은애랑 해당노드랑 비교해서, 해당노드가 크다면 위치를 바꾼다.
그림에서는 7과 5를 바꿔야한다.
바꾸었을때, 6이 포함된 오른쪽서브트리는 어차피 5가 6보다 작기때문에 순서조건을 무조건 만족한다.
왼쪽 서브트리에 대해 다시 순서조건을 따져봐야한다.
-> 위의 스텝을 반복적으로 수행.

노드가 점점 내려오므로 Downheap이라고 부른다.
한  스텝당 두번의 비교연산필요.
최악의 경우 root에서 leaf까지 내려가므로 log(n)번.
따라서 O(log(n))시간.

=>deletion 연산
역시 처음에 last노드를 root로 옮기는거 O(1)
downheap과정 O(log(n)) 
-> 총 O(log(n))시간

p.18
last node를 갱신하는법.

1. 내가 왼쪽자식이면, 부모의 오른쪽 자식으로 last node추가
2. 내가 오른쪽 자식이면 원래 last 노드의 부모가 조부모의 left child인가, 를 따지고 성립할때 까지 거슬러올라가서, 조부모의 rightchild로 내려간후 쭉 left child로 내려가서 last node추가.

->수행시간은 최악의 경우 맨위에서 위까지 올라가고 또 내려가는 이동이므로 O(log(n))

==> 실제론근데 이렇게 안한다....! 이유는 뒤에서

p.19
PQ의 sorting을 상기해보자.
PQ의 sorting 방법은 2가지로 나뉘었다.
   ①       ②
S -> PQ -> S

selection sort에서는 1번이 n^2시간, 2번이 n시간 => O(n^2)
insertion sort에서는 1번이 n시간, 2번이 n^2시간 => O(n^2)
이었다.

그런데 heap은 삽입, 삭제 모두 O(log(n))이므로, PQ에 적용시키면
1번과정을 n번 반복하므로 O(nlog(n))이고
2번과정도 n번 반복하므로 O(nlog(n))이므로
총 O(nlog(n)) 이다.

p.20
이것을 Heap sort라고 한다.
n이 커지면 커질수록 수행시간의 차이가 크게 난다.
공간은 O(n)크기 사용을 한다.
삽입, 삭제 : O(log(n))
size, empty, min : O(1)
sort : O(nlog(n))

p.21
tree는 보통 linked structure로 구현하지만,
full binary tree일때 배열로 구현해도 적절하다.
full binary tree는 complete binary tree의 일종이고,
heap은 완전이진트리이므로 배열로 구현할 수 있다.

index의 계산으로 부모-자식관계를 알 수 있는 것이 특징이었다.
node당 12바이트의 이득..! (링크드 리스트랑 다르게 부모,왼쪽자식,오른쪽자식 포인터 저장공간 필요없으므로)
이 이득이 사용하지 않은 빈공간의 배열공간보다 크다면, 배열로 쓴것이 이득이다.

하지만, heap은 배열로 구현하는것이 일반적.
왜???
배열로 저장하면 마지막 노드를 아주 쉽게 알 수 있다는것!! (마지막 인덱스니까)
O(1)시간에 last node를 update 할 수 있다!!!

배열로 구현시 inplace-heap sort가 된다!
새로운 array를 써서 거기다가 대입하는게 아니라!
방법 : 
( ) (2) (5) (6) (9) (7) 모양의 heap이 있을때,
removeMin 한번 진행을 하게되면 원래
( ) (7) (5) (6) (9) ( ) 이 되고, 다운힙을 하면
( ) (5) (7) (6) (9) ( ) 가 되어서 삭제한 2를 새로운 배열에 넣는건데,

( ) (5) (7) (6) (9) / (2)  -> 이런식으로 사용하지 않는 마지막 노드자리에 넣어줌
다음단계도 마찬가지로 ( ) (6) (7) (9) / (5) (2)
결국 ( ) (9) (7) (6) (5) (2) 처럼 역순으로 정렬된다.
그리고 1번째와 n번째, 2번째와 n-1번째 ... 자리를 바꿔줘야하므로,
수행시간은 O(nlogn) + O(n) 시간이다, inplace- sort

만약 Max heap을 썼었다면, 정순으로 정렬되니까 O(nlogn)시간에 끝나게된다.


