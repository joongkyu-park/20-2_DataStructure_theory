자료구조 13주차 이론-2

오늘 배울 내용이 중요하다.

지난시간.

그래프. vertax와 edge, 두가지의 오브젝트로 구성된 자료구조

우리가 배웠던 트리에는 노드(vertax와 비슷한)에만 데이터가 있었음.(물론 트리에서도 노드와 노드 사이의 선에 데이터가 있는 것도 있긴있음)

p.8
간선이 꽉 채워져 있을때 complete graph(?)
이때 간선의수 m 은 n(n-1)/2 -> 최대 O(n^2)

평균 간선의 수가 O(n^2)이면 조밀한그래프(dense 그래프?)
평균 간선의 수가 상수개라 총 O(n)이면 조밀하지않은그래프(스파스?? 그래프)

p.9
연산중에서 eraseVertax는 특히 조심해야한다.

incidentEdges(v) : v와 연결된 간선의 리스트. 많이 쓰이는 연산.

p.10

edge에서 vertax로 가는건 O(1)에 알아낼수있지만
vertax에서 edge로 가는건 곤란. 물론 알아낼순 있긴함. (edge object를 전부 뒤져서 원하는 vertax와 연결된 간선을 찾아야함. O(n) )

p.11
(옛날방식 구현 한번 찾아보기, 배열로 구현)

요즘 방법1.
인접리스트. adjacency list structure.

중간에 연결을 해주는 시퀀스가 하나 있음.
p.10에서의 약점. 간선->정점은 바로갈 수 있는데, 정점-> 간선은 바로 갈 수없었음. ==> 이거를 가능하게 해주는 매개체 라고 할 수 있다.

중간매개체??
u를 보자.
u를 가지고있는 시퀀스의 첫번째 필드.
-> u에 연결된 간선 object를 가리키는 링크드 리스트의 주소값을 저장.
->그 링크드리스트안에는 정점 u에 연결된 edge 오브젝트의 주소값들을 저장함(그림예제에서는 1개).

v를보자.
v를 가지고 있는 시퀀스의 첫번째 필드.
->어떤 링크드리스트의 헤드노드(첫번째)의 주소값을 가르키고있음.
->그 노드의 데이터 필드에 가보면 주소값을 저장하고있는데,
v에 연결된 edge 주소값을 저장.


그렇다면 이러한(중간매개체) 추가적인 오브젝트의 개수는 총몇개를 쓸까?
-> 정점 당 degree만큼 쓴다. -> 다 더하면 2m.
따라서 O(m) 스페이스를 더쓴다.

원래는 정점만보면 O(n) 공간, 간선만보면 O(m) 공간을 쓰니까
O(m+n)공간을 쓰고있었는데
O(m)의 공간을 추가로 씀으로써 정점->간선 으로 가는 연산을 O(1)에 실행가능. 그런데 연결된 간선의 개수가 본인 degree만큼이므로 본인과 연결된 간선을 모두 방문하려면 O(deg(v))시간.
(앞에서는 O(m)시간이었는데 지금은 거의 상수시간에 가까워짐)

u.isAjacencyTo(v)
u와 v를 주고 인접하냐? 연산을 보자.
u와연결된 간선을보고, 그간선에 연결된 u말고 다른정점? v네 -> ok.

v.isAjacencyTo(w)
v와 w가 인접하냐?
v와 연결된 간선리스트들 중에 첫번째.
나머지 정점을보니 u네. 다음 두번째.
나머지 정점을보니 w네 -> ok.

v에서 시작하면 최대 2번만에 알게되지만,
w에서 시작하면 최대 1번만에 알게된다.
-> degree가 더 작은쪽으로 해야 빠르다.

그런데 v에 연결된 간선이 몇개인지, w에 연결된 간선이 몇개인지 정보가 없다. 
따라서 최악의경우, O(max{deg(v), deg(w)})시간에 알수있다.

+)만약에 정점정보에 필드하나를 더 추가하여 자신의 degree를 적어놓고 비교해서하면되잖아?
=> 그럼 이때는 최악의경우에 O(min{deg(v),deg(w)})가 되겠다.

+)만약에 v에 연결된 간선이 10개, w에 연결된 간선이 4개라고 해보자.
이렇게하면어떻게되지?
v에 연결된 간선들의 모임에서 1번째 방문. -> 반대정점확인해보고 없으면
w에 연결된 간선들의 모임 1번째 방문. -> 없다
그럼 그다음 v의 2번째, 그다음 w의 2번째.. (번갈아서)

=> 그러다가 w의 4번째까지 방문했을때까지 연결되었다고 하지않았다면,
총 연산은 4x2번을 한것.
즉 최악의경우라도 O(2x min{deg(v),deg(w)}) 번 !
빅오표기법이니까 그냥 O(min{deg(v),deg(w)}) .

===> 따라서, 결국 isAjacencyTo 연산은 O(min{deg(v),deg(w)}) 시간


v.eraseVertax()을 해보자.
v를 지우고
v와 연관된 간선들도 지워야한다.
첫번째 간선을 지워보자.
첫번째 간선과 관계된 반대편 정점인 u에 대해서 degree 줄여주고(degree정보가 있었다면), 연결된 간선 해제해주고.. 등등 관계정리 진행.
그다음 두번째 간선과 관계된 반대편 정점 w에 대해서 마찬가지로 간선과 관계정리 해야함.
-> 정점삭제하는데 O(degree(v))시간이 걸린다. (즉 연결된 간선 하나 삭제하는데는 O(1))


p.12
Adjacency Matrix Structure. 인접행렬.

역시나 vertax object 리스트와 edge 리스트로 구성.

vertax object에 필드가 하나 더있네. 번호.
각 vertax에 0~n-1 번호가 붙어있다. 2차원 배열의 인덱스로 쓸려고.

O(nxn) 2차원 array를 만든다.
0번 정점 u와, 1번 정점v에 간선이 있다.
그러면 간선object a를 만들고, 2차원 배열에 (0,1)과 (1,0)자리에 a의 주소를 넣는다.
결국 2차원배열의 각 셀은 간선을 나타낸다는 뜻

정점에서 간선으로 갈수는없지만, 그 역할을 매트릭스가 대신해줌.
(0,1) 0번정점 -> 1번으로 갈수있음
(1,0) 1번정점 -> 0번으로 갈수있음
 
+) 옛날 방식은 2차원 배열의 값이 0or1이었다. (연결되어있다or아니다 정보만)

스파스한 그래프일경우 공간 낭비가 심할수있다.

공간
기본 O(n+m)
행렬만드는데 O(n^2)
m은 아무리커도 n^2이므로
결국 O(n^2)

<공간부분영상다시>

u.isAdjacencyTo(v)를 해보자.
먼저 u로가서 몇번? 0번
v로 가서 몇번? 1번
(0,1)로가서 -> null이아니네? -> ok.

=> 어느경우든 O(1)연산이된다.


u.incidentEdges() 해보자.
정점에서는 간선으로 갈방법은 없어. 행렬로 해야함.
u 너 몇번? 0번.
-> 0번째 row를 쭉 스캔한다. null 아닌 cell들을 출력하면됨.
-> n-1까지 스캔해야하므로 O(n)시간.

그러나 행렬에서는 eraseVertax를 하게되면, 행렬을 땡기고뭐하고 다시 재구성해야하는데 사실상 불가능하므로 그냥 n^2 다시 행렬을 만듬.
-> O(n^2)시간
insertVertex도 마찬가지.

eraseEdge는?
간선그냥 삭제해주고 행렬칸 null로만 바꾸면되니까 O(1)시간.

p.13
퍼포먼스.

















