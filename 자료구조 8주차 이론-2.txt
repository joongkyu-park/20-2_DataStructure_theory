자료구조 8주차 이론-2

지난수업.
Priority Queue ADT
엔트리는 key와 value의 페어를 저장.
key를 이용해서 우선순위를 이용하는 데이터 스트럭쳐가 PQ.

...

unsorted list를 가지고 하면 selection sort
sorted list를 가지고 하면 insertion sort

---------------------------------------------------------------------------

selection sort는 i번째 단계에서는 항상 i번 비교를 해야하기 때문에, 거의 무조건 n(n-1)/2 번 (??) 연산을 해야하는데, 

하지만 insertion sort는 베스트케이스(1번만비교)도 있기때문에
항상 n(n-1)/2 번 연산은 아니다.
=>insertion sort가 평균적으로 빠르다. (average case가 n^2/4 정도 된다.)

n^2이니까 느리다? 연산이 n인 알고리즘을 찾자?
=> n^2이 느릴려면 n이 충분히 커야한다.
n이 작을땐 insertion sort가 더 빠를수도. (n이 20개 전후일때는 더 빠를수도)

p.9
In-place Insertion-Sort : 제자리 정렬.
알고리즘을 사용할 때 처음에 입력으로 준 메모리 이외에 추가적으로 메모리를 사용하게된다. 변수들을 사용하니까. (우리같은경우엔 n개의 데이터를 S에 입력을 받는다면 P라는 방을 만들기 위해 추가적으로 O(n)의 메모리를 사용했었다)

그런데 알고리즘의 수행을 위해서 입력말고 추가적인 메모리를 사용하는데, 그 추가메모리가 '상수크기 이내' 일때 제자리 정렬 이라고 한다.
또는 log함수는 대단히 증가율이 낮은 함수이다.
따라서  추가 메모리가 O(logn)일때도 암묵적으로 in-place sort라고 한다.

그렇다면 Insertion-Sort 을 in-place로 할 수있나? -> 있다!
ppt의 그림을보자.
맨처음 5는 정렬됐다고 생각.
4 차례 때, 5와 4를 바꿀때 변수메모리 필요
2 차례, 바꾸고 바꾸고..
...
=>중요한점은, PQ방으로 옮기는게아니고, 제자리에서 하고있다.

연산시간은 역시 O(n^2)이지만
추가적인 메모리 공간은 O(1)이다. 자리를 바꾸기위한 임시변수 메모리밖에 없었기 때문.

입력을주면 그 방안에서 끝낼 수 있다는 뜻.
추가적인메모리는 상수크기이내만큼 필요.


그렇다면 selection sort도 in-place가 가능한가?
(5-4-2-3-1)
selection sort 알고리즘은 minimum을 찾아야한다.
n개가 있다면 n-1번의 비교를 통해 가장 작은 숫자를 찾고,
맨 앞에 있는 원소, 측 minimum 위치에 있는 원소와, 방금 찾은 가장 작은 숫자의 위치를 바꿔준다.
(1-4-2-3-5)
unsorted된 부분 (4-2-3-5)에서 또 미니멈을 찾고 위와같이 알고리즘을 반복한다.
그렇게하면 (1-2-4-3-5)가 된다.

따라서 selection sort도 in-place 가능

-----------------------------------------------------------------
Heaps

p.11
Heap은 바이너리 트리다. 노드에 key를 저장하는.

heap은 다음의 두가지 조건을 만족하는 바이너리 트리이다.
1. 구조적인 조건
2. 순서적인 조건

1. 구조적
heap은 구조적으로 완전이진트리(complete binary tree)이다.
완전이진트리의 특성은 h가 높이라고 한다면,
높이 0부터 h-1레벨까지의 노드들은 꽉차있고,
h높이까지 꽉차있으면 그건 full binary tree라고 부르고,
h높이(맨마지막 레벨)에 꽉차있지않다면, 노드는 왼쪽서부터 채워나간다.
(즉 h레벨에서 인터널 노드들은 왼쪽에, h-1레벨의 익스터널 노드들은 오른쪽에.)

2. 순서적
child node의 키값은 parent node의 키값보다 크다.
즉 위로 올라갈수록 key값이 작아진다.
키 값이 가장 작은 노드는 루트노드.
반대로 루트에 키 값이 가장 큰게 들어와있을수도있겠네.
그러면 heap도 루트에 min key가 있을수도있고 max key가 있을수도있겠네.
heap의 두종류
위로 올라갈수록 키값이작아지는 min-heap(최소힙)
위로 올라갈수록 키값이커져가는 max-heap(최대힙) 이 있다.
역시 부등호 방향만 다르다.
우리는 min heap으로 가정한다.
(+ key값의 중복을 허용한다면 부모노드의 키와 자식노드의 키값이 같은 상황도 있겠지만, 우리는 편의상 그런 경우는 생각x)

그런데 직계에서는 순서적 조건을 만족해야하지만,
반계에서는 순서적 조건을 만족하지 않을 수도 있다.
ex)                   2
                 5          8
            9        7

일 때 7과 8의 관계.

이 트리에서 가장 마지막에 생성된 노드는 7일 텐데, 이 노드를 last node라고 부른다. (최대 깊이에서 가장 오른쪽에 있는 노드)

p.12
n개의 데이터를 저장하고 있는 heap의 높이는 O(logn)
왜냐하면 당연히 complete binary tree 니까

높이가 h일때 모든 노드의 수는 1+2+4+ ... + 2^(h-1) + 1(최대 2^h개 까지 있을 수 있지만)
그렇다면 n>= 1+2+4+ ... + 2^(h-1) + 1 일텐데
1+2+4+ ... + 2^(h-1) = 2^h -1 이므로

따라서 n>=2^h
따라서 h<=logn 이므로 O(logn)이된다.

p.13
heap을 그러면 왜배우냐?
heap을 이용해서 PQ를 구현할 수 있다.
last node의 위치를 계속 알고 있으면 tree의 알고리즘을 이용하여 구현할 수 있다.

p.14
Insertion into a Heap

insertItem이나 insert(e)나 같은 뜻.

PQ가 heap으로 구성되어있을때,(밖에서는 sequence로 구성되있는지 heap으로 구성되어있는지모름) key값이 k인 노드를 삽입시킬때.
즉, 내부가 heap로 되어있는 PQ에 새로운 key를 삽입. (삽입전 노드갯수가 n)
구조조건과 순서조건을 만족시키면서 삽입시켜보자.
노드가 n개였을때 heap의 두 조건을 만족시켰을 것.
k가 삽입되고 노드가 n+1개가 되었을 때도 만족시켜야할것이다.

데이터를 n개 저장한 complete binary tree의 모양은 몇가지일까?
===>1가지이다.
n+1개일때도 1가지.

따라서 당연히 구조조건을 먼저 만족시켜주는 것이 쉽다.

이말은, 새로 들어온 노드를 마지막 노드 옆에 그냥 매달아주면됨. key값이 뭐가 됐던간에.

그다음에 순서조건을 만족시키자.

이건 다음시간에.


**11/23, 공부하다가**
PQ는 단지 min가 누군지 알고싶음.
heap는 최소한 min은 누군지알고, 그아래는 트리모양으로 구조화되어있긴하지만 key들이 완벽히 크기순서대로 줄서있지않음.

시퀀스로 구현(삽입or선택정렬)했을때는
min을 알뿐만아니라 이미 다음min, 그다음 min도 다 정해져있음.

그렇기 때문에 직관적으로 heap으로 구현했을 때가 러닝타임이 더 적다.
