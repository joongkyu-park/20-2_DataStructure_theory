자료구조 11주차 이론-2

지난시간
Binary Search Tree

heap(min heap)은 위쪽으로 올라갈수록 구조적으로 작아졌고
BST는 왼쪽서브트리에는 작은애들만, 오른쪽서브트리에는 큰애들만 있는 구조.

BST에서 inorder traversal을 하면, 오름차순으로 정렬시킬 수있다.
internal에만 데이터저장. 말단노드에는 비어있다.

search연산은 BST의 높이에 비례하는 수행시간. O(h)
insert도 serach 연산이 선행되기때문에 마찬가지

delete는 두가지케이스.

p.5~
i) 
지우려는 키값찾기 O(h)
if) 4를 지운다.
4를 먼저 search 
4의 자식중에 한쪽이라도 external이면
그 external과 해당노드(4)를 한꺼번에 지우므로 (removeExtenal(w)을 이용해서) 이건 O(1)이고,
남은 자식노드를 해당노드의 parent에 이어준다.
-> 총 O(h)

ii) 자식노드가 둘다 internal이면
if) 3을 지운다.

->succesor or predecessor를 찾아야한다.
succesor로 한다면, 오른쪽 서브트리에 대한 inordertravesal에서 첫번째 visit되는 노드라고 생각하면 된다 -> 이 노드를 찾으려면, 최악의경우 O(h)걸림.

일단 지우려는 노드(3) 찾는데 O(h)
+ successor(5) 찾는데 O(h)

찾았다면, 그 successor의 left child는 반드시 external 
그러면, removeExternal(successor의 left child) 하면 된다. (successor와 그의 왼쪽자식을 없애는 연산)

이렇게 하면 실제는 지우려는 노드(3)자리에 succesor(5)를 덮어 씌워야하니까 O(1)

-> O(h) + O(h) + O(1) ==> 총 O(h)




삭제 삽입 탐색 모두 O(h)인데
최악의경우 h=n일때, O(n)이 될 수 있다.

베스트 케이스일때는 O(log n)이 될수 있는데, 이런경우는 보통 풀바이너리트리이거나 완전이진트리일때 -> 왼쪽과 오른쪽 노드수가 균형이 있을때

=> 따라서 우리가 관심있는건
ballanced binary search tree를 이용.

그중에서도 AVL tree.


--------------------------------------------------------------------

p.9

AVL tree는 ballanced binary search tree 중 하나.

왼쪽 서브트리의 노드수와 오른쪽 서브트리 노드수가 비슷.

어떻게해서?

왼쪽서브트리와 오른쪽서브트리의 높이차이가 0또는 1이어야한다.
-> 이런 특성을 모든 노드가 만족해야함.

p.10
이럴때 AVL tree의 높이는 O(log n)이 된다. (이 증명은 혼자 반드시 공부해보라) 정확히는 h < 2logn n(h) + 2

설명좀해주심(영상확인)

p.11
높이가 O(log n)이니까 삽입연사도 O(log n)이냐?
--> X. 왜냐하면 삽입으로인해 AVL의 특성을 유지해야하니까.

삽입연산.

그림과같이 54를 삽입한다고 가정

그래서 54의 자리를 search하고, 매달고보니까 높이차이 특성을 만족 X
거슬러올라가서 처음 문제가되는 노드는 78. (왼쪽서브트리와 오른쪽서브트리의 높이차이가 2)
그 노드를 z라고하고 아래를 y, 그아래를 x. (x는 나, y는 부모, z는 조부모)
모양은 여러가지가 나올수 있다.
ㅇ        ㅇ
  ㅇ         ㅇ   등 총 4가지..
    ㅇ    ㅇ
이 x, y, z의 크기를 비교하여
           b ㅇ
   a ㅇ         c    ㅇ   (a<b<c)
무조건 이 모양으로 만든다.

p.12
그 모양으로 만들고나서
a와 c의 자식으로 서브트리들을 순서대로 붙여주면된다.

하나의 노드가 움직이는걸 case1 (single rotation)
두개 움지이면 case2 (double rotation)

모든 경우, 이렇게 재구성하는데 걸리는 시간이 O(1)

이렇게 재구성해도 여전히 순서조건이 성립하나?, 즉 여전히 BST의 특성을 만족하나? -> 한다.
이유?

**이해감. 시험공부할때 영상확인하면 좋을듯**

높이조건은? 

--> 역시 한번만 restructuring하면 높이조절은 끝난다.

**이해감. 이부분도 공부할때 영상확인하면 좋을듯**

수행시간?
문제가 계속 없다 그러면 맨위 까지 다 확인해야하니까 O(log n)

중간에 문제가생기면 땡큐, 멈추고 restructuring 해야하는데, 한번만하면 끝난다.
restucturing 자체는 모든과정이 O(1)

결국 O(log n)

p.13,14,15

삽입 예시

밑에 t0 t1 t2 t3 잘못되어있는것들 있음..


p.16
삭제는 복잡하다.

그림에서 32 노드를 지웠을 때,
이번엔 z가 44가 된다.
높이가 높은 쪽에 있는 자식노드가 y. 따라서 62가 y.
(삽입에는 path에있는 노드가 y었는데 사실 의미상 높이가 높은 트리를 의미)
그러면 y의 두 서브트리중, 높이가 높은쪽을 x라고하는데,
지금의 경우는 높이가 같다.
왼쪽을 x라고하면 다른방향이니까 double rotation이 발생하고
오른쪽을 x라고하면 같은방향이니까(오른쪽-오른쪽-오른쪽) single rotation이 된다.
따라서 연산을 조금이라도 줄이기 위해 오른쪽 노드를 x라고한다.

p.17
x y z 지정해줬으면 똑같이 restructuring 하면된다.
그 과정.
T1 서브트리만 44의 자식이 된다. sigle rotation.

중요한건, deletion에서는 높이가 하나 줄어들 수 있다..
그래서 구조조건이 다시 깨질수있다.. 따라서 계속 확인해줘야한다.
restructure을 두번이상호출해줘야한다 이때 z의부모노드가 z가된다.

그 확인해줘야하는지?를 확인해줘야한다.

그 경우의수 영상설명(확인)
...

<
AVL 트리는 사실좀 어렵다. 구현도 까다롭고..
이거만 잘할수있으면 자신감이 생기게 되더라..
>

p.18
restructure 1번은 O(1)이다. (single이던 double이던)

find는 당연히 O(log n)
put은 삽입후 구조조건을 위반하는지 맨위까지 확인해야하기때문에 O(log  n)
erase는 탐색하는데 O(log n) 삭제하고 restructure하는데 O(1)
그런데 높이가 줄었다. 다시 restructure -> 이게 루트노드까지 따라 올라가서 해야할수있으므로 O(log n) -> 따라서 O(log n)

따라서 모든 연산이 O(log n)이다.
이유는 높이가 O(log n)에 bound되기때문에.


끝.


AVL트리를 .. 구현해보자.. 과제는아니지만..
바이너리 서치 트리도 구현해보고.. 속도도 비교해보자..


































