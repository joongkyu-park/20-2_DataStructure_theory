자료구조 11주차 이론-1

지난시간까지는 Priority Queue.

오늘부터 Binary Search Trees.

p.1

Binary Search 는 입력과 출력이 있는 알고리즘이고..
Binary Tree는 이전 시간에 배운건데..

Binary Search Tree는 그럼..? -> 자료구조이다.
링크드 스트럭쳐로 구현하는 트리.

p.2
Binary Search Tree 라는 자료구조는,
기본적으로 바이너리 트리로 되어있는데
key entry를 저장한다. 인터널 노드에만 저장한다.

순서조건이 존재한다.
현재 노드를 v, 왼쪽자식을 u, 오른쪽 자식을 w 이라고 할때
u의 키값 <= v의 키값 <= w의 키값
이다.
이 조건을 만족할 때 Binary Search Tree 라고 부른다.

얘도 이진트리니까 traversal(preorder, postorder, inorder)이 가능하다.
ppt의 트리로 해보자.
pre : 6 2 1 4 9 8
post : 1 4 2 8 9 6
** inorder : 1 2 4 6 8 9 ** -> 특징 : 항상 오름차순으로 출력된다

n개의 똑같은 key들을 저장하는 Binary Search Tree 모양은 1개가 아니다. 
댜앙하게 있을 수 있다.
 
p.3
Search
Binary Search Tree 역시 자료구조이기때문에 탐색 삽입 삭제 연산을 할 수 있다.
이때 왼쪽에는 작은값들, 오른쪽에는 큰값들만 있기 때문에 search가 가능하다.

찾고싶은 임의의 key값 하나를 주면, 그 노드가 tree안에 있는지없는지를 알 수 있다.
그림에서 예를 들자.
예를들어 key값이 4인 데이터를 찾고싶다.
루트노드부터 시작. 재귀적으로 실행.
6 -> 더 작으니까 왼쪽으로
2 -> 더 크니까 오른쪽으로
4 -> 원하는 값!

알고리즘이 대단히 심플하다.
또 Binary Search 알고리즘과 비슷하다.
다른점은 있다.
알고리즘이 아니라 이 자료구조 자체를 Binary Search Tree이라고 한다. 그래서 수행시간에 대해 착각할 수 있다.

p.4
Insertion
아주 간단한 알고리즘.
그림에서와 같이 key가 5인 노드를 삽입하려고한다.
먼저 트리내에 5값이 있는지 search한다.
단말노드를 만났을 때 5값이 없는걸 알수 있다.
그 단말노드 자리에 5를 삽입하면 된다.

p.5
Deletion
그림에서와 같이 먼저 4를 search한다.
4를 찾았으면 지워야하는데,
if) left child가 external 이면?

맞으면 -> 오른쪽 자식이 external이던 internal이던 해당노드(4)와 왼쪽자식의 노드를 묶어서 없애준다.
이 말은 즉, 4의 부모노드 2와, 4의 오른쪽 자식노드 5 를 이어주고, 4의 연결을 끊어준다.

아니면 ->
   오른쪽 자식이 external이다 -> 위와 같이 해당노드와 오른쪽자식을 묶    어서 없애준다.
    둘다 internal이다 -> 조금 복잡하다. 아래에서 설명

p. 6
heap에서의 순서조건을 맞춰주는 거랑 비슷하게 진행된다.
그림에서, 삭제할 노드인 3과 순서적으로 가장 유사한 숫자가 해당 자리에 들어오면 된다.
3과 유사한숫자는 3의 이전숫자(pre ..ssor ?)와 3의 다음숫자(successor)가 있을텐데, successor(한번오른쪽 자식으로 간후 쭉 왼쪽자식으로 갔을때의 값)를 택한다.
successor의 왼쪽자식은 반드시 external 이다.
그 successor와 successor의 왼쪽자식을 묶어서 삭제하고, 그값을 삭제하려고했던 노드 3에 덮어씌운다.


각 연산들의 속도?
중규의 발표 대답 ㅎㅎ..
바이너리 서치 알고리즘 처럼 O(log n )으로 효율적일 것이다...? ->착각
best case일경우 O(log n)이겠지만,
그림처럼 worst case일 경우 O(n)이 된다.
따라서 Binary Search Tree의 탐색연산. 좋지않다..

문제는 삽입과 삭제연산에서 탐색을 무조건 하므로,
삽입 삭제 연산은 최악의상황에 무조건 O(n)을 진행하고, 다음 노드를 넣거나 빼는 연산을 해야한다.
삽입 : 탐색으로인한 O(n) + 노드하나 매달아주고 끝 O(1) -> O(n)
삭제 : successor을 찾는데 최악의 경우(자식이 둘다 external인 노드) O(n) + successor을 덮어쓰는데 O(1) + 삭제하는데 O(1) -> O(n)
따라서, 트리의 높이를 h 라고 했을때
탐색,삽입,삭제 연산 모두 O(h)시간이 걸린다.
-> 수행시간이 그리 좋지않다.

p.8
그럼 사용안해? -> 개션시켰다.
왼쪽 서브트리의 노드 개수와 오른쪽 서브트리의 노드 개수가 크게 차이 나지 않도록 개선시켰다. 어느정도 균형이 맞도록.

-> 이 트리를 Ballanced Binary Search Trees라고 한다.

그중에 AVL Tree를 배워보자.

p.9
당연히 AVL Tree는 Binary Search Tree안에 포함되어있는 한 종류.
AVL tree는 balanced 되어있다. (그 이유는 한번 혼자 생각해보자 논리적으로던 직관적으로던)

한 노드를 v라고 했을떄, 왼쪽 서브트리의 높이, 오른쪽 서브트리의 높이의 차이가 0또는 1 일 때 -> okay
이러한 특성을 모든 노드가 만족하는 Binary Search Tree를 AVL Tree라고 한다.

p.10
AVL tree의 높이는?
n개의 key를 저장하고있다면 O(log n)

10페이지의 내용을 정독해오기. 왜 높이가 O(log n)인지에 대한 내용. 
높이가 h인 트리의 최소 필요한 노드수 n(h)에 대한 내용.

p.11
find연산은 동일하다!

insertion
Binary Search Tree의 insert 연산하고 일단 똑같다.
seach 연산 O(log n)
삽입하는 연산 O(1)
==> 이 때 AVL의 특성이 깨질 수도 있다. 이 구조적인 특성이 변했는지 안변했는지 확인하는 과정이 필요하다.

트리의 높이가 변한 서브트리들에 대해서, 구조적인 특성이 변했는지 확인한다.
삽입한 노드를 w, 부모노드를 x, 조부모를 y, 증조부모를 z라고하자.
x(62)를 보면 왼쪽서브트리 높이 1, 오른쪽 서브트리 0 -> 만족.
y(50)를 보면 왼쪽서브트리 높이 1, 오른쪽 서브트리 2 -> 만족
z(78)를 보면 왼쪽서브트리 높이 4, 오른쪽 서브트리 2- > not okay 발견! 
따라서 78 노드(z)가 문제의 노드.

사실 원래순서는 삽입노드(w)부터 위로 올라가면서 문제노드를 찾고, 문제노드부터, 방금 지나온 path에있는 노드들에 대해서 다음과같은 프로시져를 진행한다.

위와 같이 문제노드를 포함해서 지나간 path 노드들이 x, y, z라고 하면, 즉 3개이면 일반적으로 가능한 모양은
       ㅇ          ㅇ                ㅇ       ㅇ
   ㅇ                 ㅇ          ㅇ             ㅇ 
ㅇ                 ㅇ                ㅇ              ㅇ
이렇게 4가지 모양이 있을 수 있다.
하지만 모든 경우에 p.12와 같이 노드를 재구성해준다.

중간 key값을 루트로 만들고 왼쪽자식 으론쪽자식에 나머지 노드를 연결시켜주고,
각 노드에 달려있었던 서브트리를 순서대로 매달아준다.