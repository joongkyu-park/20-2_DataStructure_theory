자료구조 5주차 -1

지난시간 복습
큐를 singly linke list로 구현하는 방법 설명했다.
큐로 마찬가지로 sequential 한 data structure이기때문에 배열과 링크드 리스트로 구현할 수 있었다.
특히, 배열로 구현할때는 circular array를 이용했었다.
큐도 역시 O(1) time 이었다.
특히 singly linke list에서, 삭제일 때, tail 쪽에서는 O(n)이 걸리므로,
rear을 tail로, front를 head로 구현해주어야했다.


Vectors or Array Lists -> 벡터를 어레이리스트로 부른다.

2.
Vector ADT는 array의 확장된 개념이다.
-> index를 이용해 data를 접근할 수 있는 구조이다.

탐색연산 : at(i)
갱신연산(update) : at(i, o)
삽입연산 : insert(i, o)
삭제연산 : erase(i)

4.
index로 데이터를 접근하기 때문에,
array-based로 구현하면 되겠다.. 더 자연스러운 구현이겠다(반드시 효율적인 구현이라는 뜻은 X)

at과 set은 O(1) 시간.

5.
그러나 insert와 erase는 다르다.
왜냐하면, index를 유지해야하기 때문.
i번째에 데이터를 넣게되면
i부터 n까지 요소들은 하나씩 미뤄야하기 때문.
최악의 경우 역시 O(n)시간

6.
삭제도 마찬가지.
i번째에 요소를 지우면
뒤에꺼를 하나씩 다 당겨와야하기 때문.
최악의경우 O(n)시간.

7.
size와 empty와 같은 연산은 당연히 O(1)
왜냐하면 n이라는 크기를 트랙킹하는 변수가 있었기 때문
at,  set도 O(1).
하지만 insert와 erase는 O(n)
또, 맨앞에서 삽입하거나 지우는 연산이 자주 일어난다면, circular fashion으로 구현하는 것도 좋겠다. 왜냐하면 맨앞에서 연산이 일어날 경우 빠르게 해결해 주기 때문. 그러나 큐처럼 맨앞, 맨뒤가 어디인지 tracing해줘야함. 이 때, 맨앞 일때만 O(1)이고 나머지는 O(n)이다.

insert할 때 크기를 초과하면,
1. 적절한 예외를 던질수도 있고
2. 메모리가 허용하는한 array를 계속늘려가면서 할 수 있다(강의실을 계속 바꿔감) 하지만, 그 방의 명칭은 여전히 '자료구조 001분반 강의실'인 것이지만, 주소는 내부적으로 계속 바뀌는것.

8.
이것이 growable array-based vector 이다.
STL 벡터는 크기를 미리 지정하지 않아도되고, 크기를 지정했다해도 알아서 크기를 늘려준다.
new array size를 정하는 방법.
1. 일정량만큼 늘려주는것. c=100일때, 100->200->300 ..
2. 두배씩 늘려주는것. 1->2->4->8->16 ...

=>어떤것이 성능 면에서 유리한가? (시간의 성능)
나중에 배우자.
그러나 일반적으로 "doubling strategy"를 사용한다.

사이즈가 늘어날때 오래 걸리는 이유는, A[i]<-S[i] 연산, 즉 복사때문인데, 예를 들어 최초사이즈가 1000이고 추가데이터가 1000이 들어온다면
incremental은 100씩 늘리기때문에 복사하는 시간이 많은데,
doubling은 한번늘리고 insert만 하면되기때문에 시간이 짧다.
그냥 충분하게 크기를 키우기때문이라고 생각하면 된다.
우리가 쓰는 STL 벡터는 doubling을 쓰고 있다고 알려져있다. Deck도.



List

10.
position adt 이란?
그냥 위치라고 생각하면 된다. 어디에 있다.
구현을 하면 address가 나온다.
index로 위치를 나타낼수도 있고, 포인터변수와같이 주소값으로 위치를 나타낼 수도 있다.
(내부적으로 인덱스도 어차피 주소로 바뀌지만)
배열에서는 cell이 데이터가 저장된 공간을 나타내고
linked list에서는 node라고 한다.
둘 다 그것들이 있는 '위치'라는 개념으로 데이터를 접근하겠다는 뜻.
p.element()는 p의 위치에있는 데이터를 나타낸다는 뜻.
c++에서 *p 라는 뜻.

11.
List ADT를 시작하자.
adt니까 역시 강의실같이 자료를 모아놓는 방이다.
역시 sequence 형태.
싱글리링크드리스트, 더블리링크드리스트와는 다르다. 이거는 구현하는 방법이고, 지금 배우는 list는 추상자료형. 감춰져있다.
list는 데이터를 접근할때, 반드시 누군가의 위치가 기준이되고, 그 기준 앞 뒤 이런식으로 다른 데이터를 상대적으로 접근한다.
그 기준이 되기위한 특별한 위치는 2가지 있다.
Iterator는 특별한 position정도로 생각하면된다.
begin() : 맨앞 원소 위치, end() : 맨 마지막 원소 위치.

upadate methods
insertFront, insertBack
eraseFront, eraseBack
->모두 front와 back의 위치를 알기때문에 인자로 위치를 넣을 필요가 없다.
하지만, 일반적인 삽입이나 삭제는
 insert(p, e)나 erase(p)같이 위치를 넣어야한다.(p : position)

12.
앞 뒤를 계속 따라가야하니까 -> doubly linked list로 구현하면 자연스러울것 같다~..
d.l.l. 는 list를 구현하기에 자연스럽다.
prev와 next는 각각 주소를 담기때문에 4byte씩 크기를 갖는다.

13.
내가 x라는 데이터를 p위치 앞에 넣고싶다.
==> p 위치를 아는 것은 다른 메소드의 몫.
p 위치에 있는 데이터를 아는 것이 X !! (그림상에서 c )
데이터를 알필요가 있는게 아니라 p라는 위치만 알면, 그 앞에 넣으면 된다.
여기서 p는 node형 포인터가 되겠다.
순서.
1. q라는 주소를, 공간을 할당한다.
데이터자리에 x를 채워놓은 후에

2. 리스트에 매달기.
*우리가 알고 있는 주소는 p와 q 밖에 없다.*
q.prev <- p.prev : p라는 위치를 이용해 b의 주소를 넣는다.
q.next <- p

3. 마무리
q.prev.next <- q
p.prev <- q


14.
순서는 약간 바뀔수 있다.
p.prev를 계속 쓰기 귀찮으니까 u라는 새로운 노드포인터를 생성.


15.
삭제 연산.
p 위치에 있는 데이터를 지우는 것.
순서.
1. 
p.prev.next <- p.next
p.next.prev <- p.prev

2.
n <- n-1
delete(p)  : 가비지컬렉션~


17.
퍼포먼스
n개의 요소가 있다면 O(n)이된다
질문))  벡터에서는 O(N)인데 무슨 차이지..?

모든 삽입 삭제 연산이 O(1)이다. 
탐색연산은 따로없고, elment()연산이 있는데
p라는 주소를 주고 데이터를 가져오는 연산. 당연히 O(1).
*혼동주의*
x라는 데이터의 위치를 찾아라, 라는 오퍼레이션은 없다.
adt에 명세되어진 다른 오퍼레이션들을 이용해서 x의 p를 찾는것.
다른 오퍼레인션들을 삽입,삭제,begin,end 연산뿐이다.
어떻게 하면 되나?
=> 그걸 할 수 있게 해주는게 iterator 같은 것.
예를들어 p = list.begin() 을 하고
p.element() 를 하면 되겠다.



 